import json
import os
import re
import signal
import sys

import langid
from dotenv import load_dotenv
from google import genai

# Tenta importar o Groq como fallback
try:
    from groq import Groq
    GROQ_AVAILABLE = True
except ImportError:
    GROQ_AVAILABLE = False
    
def clear_screen():
    """Limpa a tela do terminal."""
    os.system('cls' if os.name == 'nt' else 'clear')
    
def print_header(title):
    """Imprime um cabe√ßalho formatado."""
    clear_screen()
    print("\n" + "=" * 60)
    print(f"{title:^60}")
    print("=" * 60 + "\n")

def create_env_file_if_needed():
    """Verifica se o arquivo .env existe e, se n√£o, solicita as chaves API ao usu√°rio."""
    if not os.path.exists('.env'):
        print_header("CONFIGURA√á√ÉO INICIAL")
        print("Arquivo .env n√£o encontrado. Vamos criar um agora.")
        print("\nVoc√™ precisar√° fornecer pelo menos uma das seguintes chaves API:")
        
        print("\n1. Google Gemini API Key")
        print("   Obtenha em: https://ai.google.dev/gemini-api/docs/api-key?hl=pt-br")
        gemini_key = input("\nDigite sua chave API do Google Gemini (pressione Enter para pular): ").strip()
        
        print("\n2. Groq API Key (opcional, usado como fallback)")
        print("   Obtenha em: https://console.groq.com/keys")
        groq_key = input("\nDigite sua chave API do Groq (pressione Enter para pular): ").strip()
        
        if not gemini_key and not groq_key:
            print("\nErro: Pelo menos uma chave API √© necess√°ria para o funcionamento do aplicativo.")
            sys.exit(1)
            
        # Cria o arquivo .env
        with open('.env', 'w', encoding='utf-8') as env_file:
            if gemini_key:
                env_file.write(f"GEMINI_API_KEY={gemini_key}\n")
            if groq_key:
                env_file.write(f"GROQ_API_KEY={groq_key}\n")
                
        print("\nArquivo .env criado com sucesso!")
        input("Pressione Enter para continuar...")

# Chama a fun√ß√£o para verificar o .env antes de carregar as vari√°veis de ambiente
create_env_file_if_needed()

# Carrega vari√°veis de ambiente do arquivo .env
load_dotenv()

# Configura a API do Google Gemini
API_KEY = os.getenv("GEMINI_API_KEY")
if not API_KEY:
    print("Erro: GEMINI_API_KEY n√£o encontrada. Crie um arquivo .env com sua chave GEMINI_API_KEY.")
    sys.exit(1)

# Configura a API do Groq como fallback
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
if not GROQ_API_KEY and GROQ_AVAILABLE:
    print("Aviso: GROQ_API_KEY n√£o encontrada. N√£o ser√° poss√≠vel usar o fallback para o Groq.")

# Inicializa o cliente Gemini
client = genai.Client(api_key=API_KEY)

# Inicializa o cliente Groq se dispon√≠vel
groq_client = None
if GROQ_AVAILABLE and GROQ_API_KEY:
    groq_client = Groq(api_key=GROQ_API_KEY)

# Configura o handler para CTRL+C
def signal_handler(sig, frame):
    print("\n\nOpera√ß√£o cancelada pelo usu√°rio. As tradu√ß√µes j√° aprovadas foram salvas.")
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)


def list_directory_contents(current_dir):
    """Lista os arquivos e diret√≥rios no diret√≥rio atual."""
    try:
        items = os.listdir(current_dir)
        # Separar diret√≥rios e arquivos
        directories = [item for item in items if os.path.isdir(os.path.join(current_dir, item))]
        files = [item for item in items if os.path.isfile(os.path.join(current_dir, item))]
        
        # Ordenar alfabeticamente
        directories.sort()
        files.sort()
        
        return directories, files
    except Exception as e:
        print(f"Erro ao listar o diret√≥rio: {e}")
        return [], []

def select_file_interactively():
    """Interface interativa por linha de comando para selecionar um arquivo."""
    # Come√ßa no diret√≥rio atual
    current_dir = os.getcwd()
    
    while True:
        print_header("SELE√á√ÉO DE ARQUIVO")
        print(f"Diret√≥rio atual: {current_dir}")
        print("-" * 60)
        
        directories, files = list_directory_contents(current_dir)
        
        # Lista de todas as op√ß√µes
        options = []
        
        # Adiciona op√ß√£o para subir um n√≠vel se n√£o estiver na raiz
        if current_dir != os.path.dirname(current_dir):
            print("[0] .. (Voltar para o diret√≥rio anterior)")
            options.append(("parent", None))
        
        # Lista diret√≥rios
        for i, directory in enumerate(directories, 1):
            print(f"[{i}] üìÅ {directory}/")
            options.append(("dir", directory))
        
        # Lista arquivos
        for i, file in enumerate(files, len(directories) + 1):
            print(f"[{i}] üìÑ {file}")
            options.append(("file", file))
        
        # Solicita a escolha do usu√°rio
        print("\n(Digite q para sair)")
        choice = input("Digite o n√∫mero da op√ß√£o desejada: ")
        
        if choice.lower() == 'q':
            print("\nOpera√ß√£o cancelada pelo usu√°rio.")
            sys.exit(0)
        
        try:
            choice = int(choice)
            
            if 0 <= choice < len(options):
                option_type, option_value = options[choice]
                
                if option_type == "parent":
                    current_dir = os.path.dirname(current_dir)
                elif option_type == "dir":
                    current_dir = os.path.join(current_dir, option_value)
                elif option_type == "file":
                    return os.path.join(current_dir, option_value)
            else:
                input("Op√ß√£o inv√°lida. Pressione Enter para continuar...")
        
        except ValueError:
            input("Por favor, digite um n√∫mero v√°lido. Pressione Enter para continuar...")
        except Exception as e:
            input(f"Erro: {e}. Pressione Enter para continuar...")

def read_file(filename):
    """L√™ o arquivo e retorna seu conte√∫do."""
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            return file.read()
    except FileNotFoundError:
        print(f"Erro: Arquivo '{filename}' n√£o encontrado.")
        sys.exit(1)
    except Exception as e:
        print(f"Erro ao ler o arquivo: {e}")
        sys.exit(1)

def save_file(filename, content):
    """Salva o conte√∫do em um arquivo."""
    backup_filename = filename + '.bak'
    try:
        # Cria um backup do arquivo original se ele ainda n√£o existir
        if not os.path.exists(backup_filename):
            with open(filename, 'r', encoding='utf-8') as original:
                with open(backup_filename, 'w', encoding='utf-8') as backup:
                    backup.write(original.read())
            print(f"Backup criado como '{backup_filename}'")
        
        # Salva o novo conte√∫do
        with open(filename, 'w', encoding='utf-8') as file:
            file.write(content)
        print(f"Arquivo salvo com sucesso!")
        input("Pressione Enter para continuar...")
    except Exception as e:
        print(f"Erro ao salvar o arquivo: {e}")
        input("Pressione Enter para continuar...")

def parse_records(content):
    """Extrai os registros do conte√∫do do arquivo usando express√µes regulares."""
    pattern = r'\{\s*([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}'
    matches = re.finditer(pattern, content)
    
    records = []
    positions = []
    raw_records = []
    
    for match in matches:
        record_text = match.group(0)
        start_pos = match.start()
        end_pos = match.end()
        
        # Armazena o texto bruto do registro
        raw_records.append(record_text)
        
        # Converte o texto do registro para um dicion√°rio
        record_dict = {}
        try:
            lines = record_text.strip('{}').split('\n')
            for line in lines:
                line = line.strip()
                if line and not line.startswith('//'):  # Ignora linhas vazias e coment√°rios
                    if ':' in line:
                        parts = line.split(':', 1)
                        if len(parts) == 2:
                            key, value = parts
                            key = key.strip()
                            value = value.strip()
                            record_dict[key] = value
        except Exception as e:
            print(f"Erro ao processar registro: {e}")
            print(f"Texto do registro: {record_text}")
            continue
        
        records.append(record_dict)
        positions.append((start_pos, end_pos))
    
    return records, positions, content, raw_records

def is_portuguese(text):
    """Verifica se o texto j√° est√° em portugu√™s."""
    try:
        # O langid pode falhar em textos muito curtos ou que cont√™m muitas palavras estrangeiras
        lang, confidence = langid.classify(text)
        
        # Retorna True se for portugu√™s (pt) com uma confian√ßa razo√°vel
        return lang == 'pt' and confidence > 0.5
    except:
        # Em caso de erro, presume que n√£o √© portugu√™s
        return False

def translate_with_gemini(text, field_name, original_text=None, is_retry=False):
    """Traduz o texto usando a API do Google Gemini."""
    if is_retry:
        prompt = f"""
        Traduza o seguinte texto de ingl√™s para portugu√™s para um jogo indie. A tradu√ß√£o anterior n√£o foi satisfat√≥ria.
        
        Campo: {field_name}
        Texto original: {text}
        Tentativa anterior: {original_text}
        
        Mantenha a tradu√ß√£o com tamanho similar ao original e preserve a terminologia de jogos.
        Evite tradu√ß√µes literais que percam o significado ou o humor do original.
        N√ÉO repita o texto original junto com a tradu√ß√£o!
        
        Obrigat√≥rio: Retorne apenas o texto traduzido e nada mais. 
        N√£o adicione informa√ß√µes extras ou explica√ß√µes.
        """
    else:
        prompt = f"""
        Traduza o seguinte texto de ingl√™s para portugu√™s para um jogo indie.
        
        Campo: {field_name}
        Texto original: {text}
        
        Mantenha a tradu√ß√£o com tamanho similar ao original e preserve a terminologia de jogos.
        Evite tradu√ß√µes literais que percam o significado ou o humor do original.
        N√ÉO repita o texto original junto com a tradu√ß√£o!
        
        Obrigat√≥rio: Retorne apenas o texto traduzido e nada mais. 
        N√£o adicione informa√ß√µes extras ou explica√ß√µes.
        """
    
    try:
        print("Traduzindo com Google Gemini...")
        response = client.models.generate_content(
            model="gemini-2.0-flash",
            contents=prompt
        )
        return response.text.strip(), True
    except Exception as e:
        print(f"Erro na tradu√ß√£o com Gemini: {e}")
        return None, False

def translate_with_groq(text, field_name, original_text=None, is_retry=False):
    """Traduz o texto usando a API do Groq como fallback."""
    if not GROQ_AVAILABLE or not groq_client:
        return "ERRO NA TRADU√á√ÉO - Groq n√£o dispon√≠vel", False
    
    if is_retry:
        prompt = f"""Traduza o seguinte texto de ingl√™s para portugu√™s para um jogo indie. A tradu√ß√£o anterior n√£o foi satisfat√≥ria.
        
Campo: {field_name}
Texto original: {text}
Tentativa anterior: {original_text}
        
Mantenha a tradu√ß√£o com tamanho similar ao original e preserve a terminologia de jogos.
Evite tradu√ß√µes literais que percam o significado ou o humor do original.
N√ÉO repita o texto original junto com a tradu√ß√£o!

Obrigat√≥rio: Retorne apenas o texto traduzido e nada mais. 
N√£o adicione informa√ß√µes extras ou explica√ß√µes."""
    else:
        prompt = f"""Traduza o seguinte texto de ingl√™s para portugu√™s para um jogo indie.
        
Campo: {field_name}
Texto original: {text}
        
Mantenha a tradu√ß√£o com tamanho similar ao original e preserve a terminologia de jogos.
Evite tradu√ß√µes literais que percam o significado ou o humor do original.
N√ÉO repita o texto original junto com a tradu√ß√£o!

Obrigat√≥rio: Retorne apenas o texto traduzido e nada mais. 
N√£o adicione informa√ß√µes extras ou explica√ß√µes."""
    
    try:
        print("Traduzindo com Groq (fallback)...")
        chat_completion = groq_client.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            model="llama3-70b-8192",
        )
        return chat_completion.choices[0].message.content.strip(), True
    except Exception as e:
        print(f"Erro na tradu√ß√£o com Groq: {e}")
        return "ERRO NA TRADU√á√ÉO", False

def translate_text(text, field_name, original_text=None, is_retry=False):
    """Traduz o texto usando a API do Google Gemini com fallback para Groq."""
    # Tenta primeiro com Gemini
    result, success = translate_with_gemini(text, field_name, original_text, is_retry)
    
    # Se falhar, tenta com Groq como fallback
    if not success:
        print("Tradu√ß√£o com Gemini falhou. Tentando com Groq como fallback...")
        result, success = translate_with_groq(text, field_name, original_text, is_retry)
    
    return result

def update_content(content, positions, records, raw_records, translated_fields, field_name):
    """Atualiza o conte√∫do do arquivo com as tradu√ß√µes aprovadas."""
    # Cria uma c√≥pia do conte√∫do original
    new_content = content
    
    # Aplica as tradu√ß√µes de tr√°s para frente para evitar problemas com √≠ndices
    for i in range(len(records) - 1, -1, -1):
        if i in translated_fields:
            record = records[i]
            start_pos, end_pos = positions[i]
            raw_record = raw_records[i]
            
            # Extrai a linha com o campo a ser traduzido
            field_pattern = re.compile(r'(\s*' + re.escape(field_name) + r':\s*)([^\n]*)', re.MULTILINE)
            field_match = field_pattern.search(raw_record)
            
            if field_match:
                # Substitui o valor do campo no texto original
                prefix = field_match.group(1)  # field_name + ":"
                translated_value = translated_fields[i]
                
                # Substitui apenas a linha espec√≠fica no texto do registro
                updated_record = field_pattern.sub(f'{prefix}{translated_value}', raw_record)
                
                # Substitui o registro original pelo atualizado no conte√∫do completo
                new_content = new_content[:start_pos] + updated_record + new_content[end_pos:]
    
    return new_content

def select_from_menu(options, title, prompt="Escolha uma op√ß√£o:"):
    """Exibe um menu e retorna a op√ß√£o selecionada."""
    while True:
        print_header(title)
        
        for i, option in enumerate(options):
            print(f"[{i+1}] {option}")
        
        print("\n(Digite q para sair)")
        choice = input(f"{prompt} ")
        
        if choice.lower() == 'q':
            return None
        
        try:
            choice = int(choice)
            if 1 <= choice <= len(options):
                return options[choice-1]
            else:
                input("Op√ß√£o inv√°lida. Pressione Enter para continuar...")
        except ValueError:
            input("Por favor, digite um n√∫mero v√°lido. Pressione Enter para continuar...")

def select_field_interactively(available_fields):
    """Seleciona um campo para tradu√ß√£o de forma interativa."""
    fields_list = sorted(list(available_fields))
    
    while True:
        print_header("SELE√á√ÉO DE CAMPO PARA TRADU√á√ÉO")
        
        for i, field in enumerate(fields_list, 1):
            print(f"[{i}] {field}")
        
        print("\n(Digite q para sair)")
        choice = input("Digite o n√∫mero do campo que deseja traduzir: ")
        
        if choice.lower() == 'q':
            print("\nOpera√ß√£o cancelada pelo usu√°rio.")
            sys.exit(0)
        
        try:
            choice = int(choice)
            if 1 <= choice <= len(fields_list):
                return fields_list[choice-1]
            else:
                input("Op√ß√£o inv√°lida. Pressione Enter para continuar...")
        except ValueError:
            input("Por favor, digite um n√∫mero v√°lido. Pressione Enter para continuar...")

def show_translation_options(history_index, history_length):
    """Exibe as op√ß√µes para o usu√°rio durante a tradu√ß√£o."""
    print("\nOp√ß√µes:")
    print("[1] Aprovar esta tradu√ß√£o")
    print("[2] Gerar nova tradu√ß√£o")
    
    if history_index > 0:
        print("[3] Ver tradu√ß√£o anterior")
    
    if history_index < history_length - 1:
        print("[4] Ver pr√≥xima tradu√ß√£o")
    
    print("[5] Usar texto original")
    print("[6] Modificar manualmente")
    print("[q] Sair")

def get_translation_choice(history_index, history_length):
    """Obt√©m a escolha do usu√°rio para a tradu√ß√£o atual."""
    show_translation_options(history_index, history_length)
    
    while True:
        choice = input("\nEscolha uma op√ß√£o: ").lower()
        
        if choice == 'q':
            return 'quit'
        
        try:
            choice = int(choice)
            if choice == 1:
                return 'approve'
            elif choice == 2:
                return 'new'
            elif choice == 3 and history_index > 0:
                return 'previous'
            elif choice == 4 and history_index < history_length - 1:
                return 'next'
            elif choice == 5:
                return 'original'
            elif choice == 6:
                return 'manual'
            else:
                print("Op√ß√£o inv√°lida. Tente novamente.")
        except ValueError:
            print("Por favor, digite um n√∫mero v√°lido.")

def main():
    """Fun√ß√£o principal do script."""
    try:
        # Banner inicial
        print_header("TRADUTOR DE JOGOS INDIE")
        input("Pressione Enter para selecionar um arquivo...")
        
        # Seleciona o arquivo
        filename = select_file_interactively()
        if not filename:
            print("Nenhum arquivo selecionado. Encerrando.")
            sys.exit(0)
        
        print_header("PROCESSANDO ARQUIVO")
        print(f"Arquivo selecionado: {filename}")
        
        # L√™ o conte√∫do do arquivo
        content = read_file(filename)
        
        # Extrai os registros do conte√∫do
        records, positions, content, raw_records = parse_records(content)
        
        print(f"Foram encontrados {len(records)} registros no arquivo.")
        input("Pressione Enter para continuar...")
        
        # Obt√©m os campos dispon√≠veis para tradu√ß√£o
        if not records:
            print("Nenhum registro encontrado no arquivo. Encerrando.")
            sys.exit(1)
        
        available_fields = set()
        for record in records:
            available_fields.update(record.keys())
        
        # Seleciona o campo para tradu√ß√£o
        field_name = select_field_interactively(available_fields)
        
        # Dicion√°rio para armazenar as tradu√ß√µes aprovadas
        translated_fields = {}
        
        # Conte√∫do atualizado que ser√° salvo a cada aprova√ß√£o
        current_content = content
        
        # Processa cada registro
        for i, record in enumerate(records):
            if field_name in record:
                print_header(f"TRADU√á√ÉO DE REGISTRO {i+1}/{len(records)}")
                print(f"Nome: {record.get('name', record.get('devname', 'N/A'))}")
                
                original_text = record[field_name]
                print(f"\nOriginal ({field_name}):\n{original_text}")
                
                # Verifica se o texto j√° est√° em portugu√™s
                if is_portuguese(original_text):
                    print("\nTexto j√° est√° em portugu√™s. Pulando para o pr√≥ximo registro...")
                    input("Pressione Enter para continuar...")
                    continue
                
                # Traduz o texto
                print("\nGerando tradu√ß√£o inicial...")
                translated_text = translate_text(original_text, field_name)
                
                # Hist√≥rico de tradu√ß√µes para este registro
                translation_history = [translated_text]
                history_index = 0
                
                # Loop at√© que a tradu√ß√£o seja aprovada
                is_approved = False
                while not is_approved:
                    print_header(f"TRADU√á√ÉO DE REGISTRO {i+1}/{len(records)}")
                    print(f"Nome: {record.get('name', record.get('devname', 'N/A'))}")
                    print(f"\nOriginal ({field_name}):\n{original_text}")
                    
                    current_translation = translation_history[history_index]
                    print(f"\nTradu√ß√£o ({history_index + 1}/{len(translation_history)}):\n{current_translation}")
                    
                    # Obt√©m a escolha do usu√°rio
                    choice = get_translation_choice(history_index, len(translation_history))
                    
                    if choice == 'approve':
                        # Aprova a tradu√ß√£o atual
                        translated_fields[i] = current_translation
                        is_approved = True
                        
                        # Atualiza o conte√∫do do arquivo em tempo real
                        current_content = update_content(current_content, positions, records, raw_records, {i: current_translation}, field_name)
                        save_file(filename, current_content)
                        print(f"Tradu√ß√£o aplicada ao arquivo em tempo real.")
                    
                    elif choice == 'new':
                        # Gera uma nova tradu√ß√£o
                        print("\nGerando nova tradu√ß√£o...")
                        new_translation = translate_text(original_text, field_name, current_translation, is_retry=True)
                        translation_history.append(new_translation)
                        history_index = len(translation_history) - 1
                    
                    elif choice == 'previous':
                        # Vai para a tradu√ß√£o anterior no hist√≥rico
                        history_index -= 1
                    
                    elif choice == 'next':
                        # Vai para a pr√≥xima tradu√ß√£o no hist√≥rico
                        history_index += 1
                    
                    elif choice == 'original':
                        # Usa o texto original (sem tradu√ß√£o)
                        translated_fields[i] = original_text
                        is_approved = True
                        
                        # Atualiza o conte√∫do do arquivo em tempo real
                        current_content = update_content(current_content, positions, records, raw_records, {i: original_text}, field_name)
                        save_file(filename, current_content)
                        print(f"Texto original mantido e aplicado ao arquivo.")
                    
                    elif choice == 'manual':
                        # Permite modifica√ß√£o manual
                        print("\nDigite a tradu√ß√£o manualmente:")
                        manual_translation = input("> ")
                        translation_history.append(manual_translation)
                        history_index = len(translation_history) - 1
                    
                    elif choice == 'quit':
                        # Sai do programa
                        print("\nOpera√ß√£o cancelada pelo usu√°rio.")
                        sys.exit(0)
        
        print_header("CONCLUS√ÉO")
        print("Processo de tradu√ß√£o conclu√≠do com sucesso!")
        input("Pressione Enter para sair...")
    
    except KeyboardInterrupt:
        print("\n\nOpera√ß√£o cancelada pelo usu√°rio. As tradu√ß√µes j√° aprovadas foram salvas.")
        sys.exit(0)

if __name__ == "__main__":
    main()